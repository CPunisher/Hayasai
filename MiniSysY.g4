grammar MiniSysY;

compUnit: funcDef;
decl: constDecl | varDecl;
btype: 'int';
constDecl: 'const' btype constDef (',' constDef)* ';';
constDef: IDENT '=' constInitVal;
constInitVal: constExp;
constExp: addExp;
varDecl: btype varDef (',' varDef)* ';';
varDef: IDENT | IDENT '=' initVal;
initVal: exp;

funcDef: funcType IDENT '(' ')' block;
funcType: 'int';
block: '{' blockItem* '}';
blockItem: decl | stmt;
stmt: assignStmt | block | ifStmt | expStmt | retStmt;
assignStmt: lVal '=' exp ';';
ifStmt: 'if' '(' cond ')' stmt ('else' stmt)?;
retStmt: 'return' exp ';';
expStmt: exp? ';';

lVal: IDENT;
exp: addExp;
cond: lOrExp;
addExp: mulExp (unaryOp mulExp)*;
mulExp: unaryExp (binaryOp unaryExp)*;
unaryExp: basicUnaryExp | funcCall;
basicUnaryExp: (unaryOp)* primaryExp;
funcCall: IDENT '(' funcRParams? ')';
funcRParams: exp (',' exp)*;
primaryExp: '(' exp ')' | lVal | number;
relExp: addExp (compOp addExp)*;
eqExp: relExp (equalOp relExp)*;
lAndExp: eqExp (LOGIC_AND eqExp)*;
lOrExp: lAndExp (LOGIC_OR lAndExp)*;

number: DEC_CONST | OCT_CONST | HEX_CONST;
compOp: LESS | GREATER | LEQUAL | GEQUAL;
equalOp: EQUAL | NOT_EQUAL;
unaryOp: PLUS | MINUS | NOT;
binaryOp: MUL | DIV | MOD;

PLUS: '+';
MINUS: '-';
NOT: '!';
MUL: '*';
DIV: '/';
MOD: '%';
LESS: '<';
GREATER: '>';
LEQUAL: '<=';
GEQUAL: '>=';
EQUAL: '==';
NOT_EQUAL: '!=';
LOGIC_AND: '&&';
LOGIC_OR: '||';
IDENT: [_a-zA-Z] | [_a-zA-Z] [_a-zA-Z0-9]+;
DEC_CONST: [1-9] [0-9]*;
OCT_CONST: '0' [0-7]*;
HEX_CONST: ('0x' | '0X') [0-9a-fA-F]+;
COMMENT: ('/*' .*? '*/' | '//' .*? [\n\r]) -> skip;
WHITE_SPACE: [ \t\n\r] -> skip;